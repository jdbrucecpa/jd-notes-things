<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
    <title>Recording Widget</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html, body {
        background: transparent;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
        width: 100%;
        height: 100%;
      }

      .widget-wrapper {
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: flex-end;
      }

      .widget-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        background: rgba(24, 24, 27, 0.95);
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 24px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(12px);
        -webkit-app-region: drag;
        padding: 12px 10px;
        gap: 8px;
        width: 64px;
      }

      /* Timer display */
      .timer-section {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
      }

      .timer-display {
        font-size: 11px;
        font-weight: 600;
        color: #fff;
        font-variant-numeric: tabular-nums;
        letter-spacing: 0.5px;
      }

      /* Divider */
      .divider {
        width: 32px;
        height: 1px;
        background: rgba(255, 255, 255, 0.12);
      }

      /* Control buttons */
      .widget-controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        -webkit-app-region: no-drag;
      }

      .control-btn {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s ease;
        background: rgba(255, 255, 255, 0.08);
        color: rgba(255, 255, 255, 0.6);
      }

      .control-btn:hover {
        background: rgba(255, 255, 255, 0.15);
        color: #fff;
      }

      .control-btn.pinned {
        color: #10b981;
        background: rgba(16, 185, 129, 0.15);
      }

      .control-btn.pinned:hover {
        background: rgba(16, 185, 129, 0.25);
      }

      /* Record/Stop button */
      .record-btn {
        width: 44px;
        height: 44px;
        border-radius: 12px;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s ease;
        background: linear-gradient(180deg, #ef4444 0%, #dc2626 100%);
        color: #fff;
      }

      .record-btn:hover {
        transform: scale(1.05);
        background: linear-gradient(180deg, #f87171 0%, #ef4444 100%);
      }

      .record-btn .record-icon {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #fff;
      }

      .record-btn .stop-icon {
        display: none;
        width: 14px;
        height: 14px;
        background: #fff;
        border-radius: 3px;
      }

      .record-btn.recording .record-icon {
        display: none;
      }

      .record-btn.recording .stop-icon {
        display: block;
      }

      /* Recording state */
      .widget-container.recording {
        border-color: rgba(239, 68, 68, 0.3);
      }

      .widget-container.recording .timer-display {
        color: #ef4444;
      }

      /* Status dot */
      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.25);
        transition: all 0.2s ease;
      }

      .widget-container.recording .status-dot {
        background: #ef4444;
        animation: pulse 1.5s ease-in-out infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.4; }
      }

      /* Close button - hidden, use pin button to hide widget */
      .close-btn {
        display: none !important;
      }

      /* Info tooltip */
      .info-tooltip {
        position: absolute;
        right: 70px;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(24, 24, 27, 0.98);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 10px;
        padding: 12px;
        width: 220px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        display: none;
        z-index: 100;
        -webkit-app-region: no-drag;
      }

      .info-tooltip.show {
        display: block;
      }

      .info-tooltip::after {
        content: '';
        position: absolute;
        right: -8px;
        top: 50%;
        transform: translateY(-50%);
        border: 8px solid transparent;
        border-left-color: rgba(255, 255, 255, 0.15);
      }

      .info-title {
        font-size: 13px;
        font-weight: 600;
        color: #fff;
        margin-bottom: 8px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .info-row {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 6px;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.7);
      }

      .info-row:last-child {
        margin-bottom: 0;
      }

      .info-row svg {
        width: 12px;
        height: 12px;
        flex-shrink: 0;
        opacity: 0.6;
      }

      .info-label {
        color: rgba(255, 255, 255, 0.5);
        min-width: 50px;
      }

      .info-value {
        color: #fff;
      }

      .info-platform {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        font-size: 10px;
        text-transform: capitalize;
      }

      .info-platform.zoom { color: #2D8CFF; }
      .info-platform.teams { color: #6264A7; }
      .info-platform.meet { color: #00897B; }
      .info-platform.in-person { color: #10b981; }

      .info-hint {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        font-size: 10px;
        color: rgba(255, 255, 255, 0.4);
        text-align: center;
      }

      /* Meeting selection mode */
      .widget-container.select-mode {
        width: 220px;
        padding: 12px;
      }

      .widget-container.select-mode .timer-section,
      .widget-container.select-mode .divider,
      .widget-container.select-mode .widget-controls {
        display: none;
      }

      .meeting-select {
        display: none;
        flex-direction: column;
        gap: 8px;
        width: 100%;
        -webkit-app-region: no-drag;
      }

      .widget-container.select-mode .meeting-select {
        display: flex;
      }

      .select-title {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.6);
        text-align: center;
        margin-bottom: 4px;
      }

      .meeting-option {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 10px 12px;
        cursor: pointer;
        transition: all 0.15s ease;
        text-align: left;
        color: #fff;
      }

      .meeting-option:hover {
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(255, 255, 255, 0.2);
      }

      .meeting-option-title {
        font-size: 12px;
        font-weight: 500;
        margin-bottom: 2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .meeting-option-time {
        font-size: 10px;
        color: rgba(255, 255, 255, 0.5);
      }

      .cancel-btn {
        background: none;
        border: 1px solid rgba(255, 255, 255, 0.15);
        color: rgba(255, 255, 255, 0.6);
        padding: 8px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 11px;
        transition: all 0.15s ease;
      }

      .cancel-btn:hover {
        background: rgba(255, 255, 255, 0.08);
        color: #fff;
      }

      /* v1.2 fix: Recording options mode */
      .widget-container.options-mode {
        width: 280px;
        padding: 14px;
      }

      .widget-container.options-mode .timer-section,
      .widget-container.options-mode .divider,
      .widget-container.options-mode .widget-controls {
        display: none;
      }

      .widget-container.options-mode .meeting-select {
        display: none;
      }

      .recording-options {
        display: none;
        flex-direction: column;
        gap: 4px;
        width: 100%;
        -webkit-app-region: no-drag;
      }

      .widget-container.options-mode .recording-options {
        display: flex;
      }

      .options-title {
        font-size: 12px;
        font-weight: 500;
        color: rgba(255, 255, 255, 0.7);
        text-align: left;
        margin-bottom: 8px;
        padding-bottom: 6px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .recording-option {
        display: flex;
        align-items: center;
        gap: 10px;
        background: transparent;
        border: none;
        border-radius: 6px;
        padding: 10px 12px;
        cursor: pointer;
        transition: background 0.12s ease;
        text-align: left;
        color: #fff;
      }

      .recording-option:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .recording-option .option-icon {
        font-size: 16px;
        flex-shrink: 0;
        width: 24px;
        text-align: center;
        opacity: 0.9;
      }

      .recording-option .option-content {
        flex: 1;
        min-width: 0;
      }

      .recording-option .option-title {
        font-size: 13px;
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: 1.3;
      }

      .recording-option .option-subtitle {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.5);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-top: 2px;
      }

      /* Remove colorful borders - keep it utilitarian */
      .recording-option.platform-zoom,
      .recording-option.platform-teams,
      .recording-option.platform-meet,
      .recording-option.platform-calendar,
      .recording-option.action-append,
      .recording-option.action-replace,
      .recording-option.action-new {
        border-left: none;
      }

      .options-divider {
        height: 1px;
        background: rgba(255, 255, 255, 0.08);
        margin: 6px 0;
      }

      /* Options cancel button - slightly larger */
      .recording-options .cancel-btn {
        margin-top: 6px;
        padding: 10px;
        font-size: 12px;
        border: none;
        background: rgba(255, 255, 255, 0.05);
      }

      .recording-options .cancel-btn:hover {
        background: rgba(255, 255, 255, 0.1);
      }
    </style>
  </head>
  <body>
    <div class="widget-wrapper">
      <!-- Info tooltip (shows on hover of info button) -->
      <div class="info-tooltip" id="infoTooltip">
        <div class="info-title" id="infoTitle">Meeting Title</div>
        <div class="info-row">
          <span class="info-label">Time:</span>
          <span class="info-value" id="infoTime">--</span>
        </div>
        <div class="info-row">
          <span class="info-label">Platform:</span>
          <span class="info-platform" id="infoPlatform">--</span>
        </div>
        <div class="info-row">
          <span class="info-label">Participants:</span>
          <span class="info-value" id="infoParticipants">--</span>
        </div>
        <div class="info-hint">Click to open in app</div>
      </div>

      <div class="widget-container" id="widgetContainer">
        <!-- Timer section -->
        <div class="timer-section">
          <div class="status-dot" id="statusDot"></div>
          <div class="timer-display" id="timerDisplay">00:00</div>
        </div>

        <!-- Divider -->
        <div class="divider"></div>

        <!-- Controls -->
        <div class="widget-controls">
          <!-- Info button -->
          <button class="control-btn" id="infoBtn" title="Meeting info">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"/>
              <path d="M12 16v-4M12 8h.01"/>
            </svg>
          </button>

          <!-- Pin button -->
          <button class="control-btn pinned" id="pinBtn" title="Always on top">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
              <path d="M16 12V4h1V2H7v2h1v8l-2 2v2h5.2v6h1.6v-6H18v-2l-2-2z"/>
            </svg>
          </button>

          <!-- Record/Stop button -->
          <button class="record-btn" id="recordBtn" title="Start recording">
            <div class="record-icon"></div>
            <div class="stop-icon"></div>
          </button>
        </div>

        <!-- Meeting selection (hidden by default) -->
        <div class="meeting-select" id="meetingSelect">
          <div class="select-title">Select a meeting:</div>
          <div id="meetingOptions"></div>
          <button class="cancel-btn" id="cancelBtn">Cancel</button>
        </div>

        <!-- v1.2 fix: Recording options (hidden by default) -->
        <div class="recording-options" id="recordingOptions">
          <div class="options-title">Start recording:</div>
          <div id="optionsList"></div>
          <button class="cancel-btn" id="cancelOptionsBtn">Cancel</button>
        </div>
      </div>

      <!-- Close button -->
      <button class="close-btn" id="closeBtn" title="Close">
        <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>

    <script>
      // Widget state (display only - actual state comes from main app)
      let isRecording = false;
      let recordingStartTime = null;
      let timerInterval = null;
      let currentMeetingId = null;
      let currentMeetingInfo = null; // Store meeting info for tooltip
      let isAlwaysOnTop = true;

      // DOM elements
      const widgetContainer = document.getElementById('widgetContainer');
      const timerDisplay = document.getElementById('timerDisplay');
      const statusDot = document.getElementById('statusDot');
      const recordBtn = document.getElementById('recordBtn');
      const infoBtn = document.getElementById('infoBtn');
      const infoTooltip = document.getElementById('infoTooltip');
      const pinBtn = document.getElementById('pinBtn');
      const closeBtn = document.getElementById('closeBtn');
      const meetingSelect = document.getElementById('meetingSelect');
      const meetingOptions = document.getElementById('meetingOptions');
      const cancelBtn = document.getElementById('cancelBtn');
      // v1.2 fix: Recording options elements
      const recordingOptions = document.getElementById('recordingOptions');
      const optionsList = document.getElementById('optionsList');
      const cancelOptionsBtn = document.getElementById('cancelOptionsBtn');

      // Escape HTML to prevent XSS
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Format time as MM:SS or HH:MM:SS
      function formatTime(seconds) {
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;

        if (hrs > 0) {
          return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      }

      // Update timer display
      function updateTimer() {
        if (recordingStartTime) {
          const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
          timerDisplay.textContent = formatTime(elapsed);
        }
      }

      // v1.2 fix: Truncate text to fit in UI
      function truncateText(text, maxLength = 30) {
        if (!text) return '';
        return text.length > maxLength ? text.substring(0, maxLength - 3) + '...' : text;
      }

      // v1.2 fix: Get platform icon
      function getPlatformIcon(platform) {
        const icons = {
          'zoom': 'ðŸ“¹',
          'teams': 'ðŸ’¼',
          'meet': 'ðŸŽ¥',
          'calendar': 'ðŸ“…',
          'in-person': 'ðŸŽ™ï¸'
        };
        return icons[platform?.toLowerCase()] || 'ðŸŽ™ï¸';
      }

      // v1.2 fix: Get platform class for styling
      function getPlatformClass(platform) {
        if (!platform) return '';
        const p = platform.toLowerCase();
        if (p.includes('zoom')) return 'platform-zoom';
        if (p.includes('teams')) return 'platform-teams';
        if (p.includes('meet')) return 'platform-meet';
        if (p.includes('calendar')) return 'platform-calendar';
        return '';
      }

      // v1.2 fix: Show recording options dialog
      function showRecordingOptions(options) {
        optionsList.innerHTML = '';

        options.forEach((option, index) => {
          // Add divider before "New Meeting" option if there were previous options
          if (option.type === 'new' && index > 0) {
            const divider = document.createElement('div');
            divider.className = 'options-divider';
            optionsList.appendChild(divider);
          }

          const btn = document.createElement('button');
          btn.className = 'recording-option ' + (option.className || '');
          btn.innerHTML = `
            <span class="option-icon">${escapeHtml(option.icon)}</span>
            <div class="option-content">
              <div class="option-title">${escapeHtml(option.title)}</div>
              ${option.subtitle ? `<div class="option-subtitle">${escapeHtml(option.subtitle)}</div>` : ''}
            </div>
          `;
          btn.addEventListener('click', () => selectRecordingOption(option));
          optionsList.appendChild(btn);
        });

        widgetContainer.classList.add('options-mode');
      }

      // v1.2 fix: Hide recording options dialog
      function hideRecordingOptions() {
        widgetContainer.classList.remove('options-mode');
      }

      // v1.2 fix: Handle recording option selection
      async function selectRecordingOption(option) {
        hideRecordingOptions();

        try {
          let result;
          if (option.action) {
            // Recording with action (append, overwrite, new) for existing meeting
            result = await window.widgetAPI.startRecordingWithAction(option.meetingId, option.action);
          } else {
            // Simple start recording
            currentMeetingId = option.meetingId || null;
            result = await window.widgetAPI.startRecording(currentMeetingId);
          }
          // UI update will come from sync-state event
        } catch (error) {
          console.error('Failed to start recording:', error);
        }
      }

      // v1.2 fix: Context-aware recording - check conditions and show options if needed
      async function handleRecordClick() {
        if (isRecording) {
          // Stop recording
          await stopRecording();
          return;
        }

        try {
          // Get recording context from main process
          const { success, context } = await window.widgetAPI.getRecordingContext();

          if (!success || !context) {
            // Fallback to simple recording
            await startRecording();
            return;
          }

          // Build options based on context
          const options = [];

          // 1. Detected platform meeting
          if (context.detectedMeeting) {
            const platform = context.detectedMeeting.platform;
            options.push({
              type: 'detected',
              icon: getPlatformIcon(platform),
              title: `Start ${platform.charAt(0).toUpperCase() + platform.slice(1)} Meeting`,
              subtitle: truncateText(context.detectedMeeting.title, 25),
              meetingId: context.detectedMeeting.id,
              className: getPlatformClass(platform),
            });
          }

          // 2. Upcoming calendar events
          if (context.upcomingCalendarEvents && context.upcomingCalendarEvents.length > 0) {
            context.upcomingCalendarEvents.forEach(event => {
              options.push({
                type: 'calendar',
                icon: 'ðŸ“…',
                title: truncateText(event.title, 28),
                subtitle: new Date(event.startTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                meetingId: event.id,
                className: 'platform-calendar',
              });
            });
          }

          // 3. Currently viewed meeting with transcript options
          if (context.currentViewedMeeting && context.currentViewedMeeting.id) {
            const meeting = context.currentViewedMeeting;
            const meetingTitle = truncateText(meeting.title, 22);

            if (meeting.hasTranscript) {
              // Has transcript - offer append and replace
              options.push({
                type: 'append',
                icon: 'ðŸ“Ž',
                title: `Append to "${meetingTitle}"`,
                subtitle: 'Add to existing transcript',
                meetingId: meeting.id,
                action: 'append',
                className: 'action-append',
              });
              options.push({
                type: 'replace',
                icon: 'ðŸ”„',
                title: `Replace "${meetingTitle}"`,
                subtitle: 'Overwrite existing transcript',
                meetingId: meeting.id,
                action: 'overwrite',
                className: 'action-replace',
              });
            } else {
              // No transcript - just record to this meeting
              options.push({
                type: 'existing',
                icon: 'ðŸŽ™ï¸',
                title: `Record "${meetingTitle}"`,
                subtitle: 'Record to open meeting',
                meetingId: meeting.id,
                action: 'new',
                className: 'action-new',
              });
            }
          }

          // 4. New meeting option (always available)
          options.push({
            type: 'new',
            icon: 'âž•',
            title: 'New In-Person Meeting',
            subtitle: 'Start fresh recording',
            meetingId: null,
            className: 'action-new',
          });

          // Decision logic based on user requirements:
          // - If no detected meeting, no calendar event within 10 minutes, and app not open to a meeting: start new meeting silently
          // - Otherwise: show options

          const hasDetectedMeeting = !!context.detectedMeeting;
          const hasUpcomingCalendar = context.upcomingCalendarEvents && context.upcomingCalendarEvents.length > 0;
          const hasOpenMeeting = !!context.currentViewedMeeting?.id;

          if (!hasDetectedMeeting && !hasUpcomingCalendar && !hasOpenMeeting) {
            // No context - just start new meeting
            await window.widgetAPI.startRecording(null);
          } else {
            // Show options dialog
            showRecordingOptions(options);
          }

        } catch (error) {
          console.error('Error getting recording context:', error);
          // Fallback to simple recording
          await startRecording();
        }
      }

      // Start recording - just tells main app (simple version, kept for backward compatibility)
      async function startRecording() {
        try {
          const result = await window.widgetAPI.startRecording(currentMeetingId);
          // UI update will come from sync-state event
        } catch (error) {
          console.error('Failed to start recording:', error);
        }
      }

      // Stop recording - just tells main app
      async function stopRecording() {
        try {
          const result = await window.widgetAPI.stopRecording();
          // UI update will come from sync-state event
        } catch (error) {
          console.error('Failed to stop recording:', error);
        }
      }

      // Update UI based on state from main app
      function updateUI() {
        if (isRecording) {
          recordBtn.classList.add('recording');
          recordBtn.title = 'Stop recording';
          widgetContainer.classList.add('recording');
        } else {
          recordBtn.classList.remove('recording');
          recordBtn.title = 'Start recording';
          widgetContainer.classList.remove('recording');
          timerDisplay.textContent = '00:00';
        }
      }

      // Update pin button state
      function updatePinButton() {
        if (isAlwaysOnTop) {
          pinBtn.classList.add('pinned');
          pinBtn.title = 'Always on top (click to disable)';
        } else {
          pinBtn.classList.remove('pinned');
          pinBtn.title = 'Click to keep on top';
        }
      }

      // Update info tooltip with meeting data
      function updateInfoTooltip(meetingInfo) {
        currentMeetingInfo = meetingInfo;

        if (!meetingInfo) {
          document.getElementById('infoTitle').textContent = 'No meeting';
          document.getElementById('infoTime').textContent = '--';
          document.getElementById('infoPlatform').textContent = '--';
          document.getElementById('infoPlatform').className = 'info-platform';
          document.getElementById('infoParticipants').textContent = '--';
          return;
        }

        document.getElementById('infoTitle').textContent = meetingInfo.title || 'Untitled Meeting';

        // Format time
        if (meetingInfo.startTime) {
          const start = new Date(meetingInfo.startTime);
          document.getElementById('infoTime').textContent = start.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        } else {
          document.getElementById('infoTime').textContent = '--';
        }

        // Platform
        const platform = meetingInfo.platform || 'in-person';
        document.getElementById('infoPlatform').textContent = platform;
        document.getElementById('infoPlatform').className = 'info-platform ' + platform.toLowerCase();

        // Participants
        const participants = meetingInfo.participants || [];
        if (participants.length > 0) {
          const names = participants.slice(0, 3).map(p => p.name || p.email?.split('@')[0] || 'Unknown');
          let text = names.join(', ');
          if (participants.length > 3) {
            text += ` +${participants.length - 3}`;
          }
          document.getElementById('infoParticipants').textContent = text;
        } else {
          document.getElementById('infoParticipants').textContent = 'None';
        }
      }

      // Show meeting selection
      function showMeetingSelect(meetings) {
        meetingOptions.innerHTML = '';
        meetings.forEach(meeting => {
          const option = document.createElement('button');
          option.className = 'meeting-option';
          const startTime = new Date(meeting.startTime);
          option.innerHTML = `
            <div class="meeting-option-title">${escapeHtml(meeting.title || 'Untitled')}</div>
            <div class="meeting-option-time">${startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
          `;
          option.addEventListener('click', () => selectMeeting(meeting));
          meetingOptions.appendChild(option);
        });
        widgetContainer.classList.add('select-mode');
      }

      // Select a meeting
      function selectMeeting(meeting) {
        currentMeetingId = meeting.id;
        currentMeetingInfo = meeting;
        updateInfoTooltip(meeting);
        widgetContainer.classList.remove('select-mode');
        startRecording();
      }

      // Event listeners
      // v1.2 fix: Use context-aware recording handler
      recordBtn.addEventListener('click', handleRecordClick);

      // v1.2 fix: Cancel options button handler
      cancelOptionsBtn.addEventListener('click', () => {
        hideRecordingOptions();
      });

      // Info button - show tooltip on hover, open meeting on click
      infoBtn.addEventListener('mouseenter', () => {
        infoTooltip.classList.add('show');
      });

      infoBtn.addEventListener('mouseleave', () => {
        infoTooltip.classList.remove('show');
      });

      infoBtn.addEventListener('click', () => {
        // Open the meeting in the main app
        window.widgetAPI.openMeeting(currentMeetingId);
      });

      pinBtn.addEventListener('click', async () => {
        try {
          const newState = !isAlwaysOnTop;
          const result = await window.widgetAPI.toggleAlwaysOnTop(newState);
          if (result.success) {
            isAlwaysOnTop = result.alwaysOnTop;
            updatePinButton();
          }
        } catch (error) {
          console.error('Failed to toggle always-on-top:', error);
        }
      });

      closeBtn.addEventListener('click', () => {
        window.widgetAPI.hideWidget();
      });

      cancelBtn.addEventListener('click', () => {
        widgetContainer.classList.remove('select-mode');
        window.widgetAPI.hideWidget();
      });

      // Listen for updates from main process
      window.widgetAPI.onUpdate((event, data) => {
        if (data.type === 'show') {
          if (data.meetings && data.meetings.length > 1) {
            showMeetingSelect(data.meetings);
          } else if (data.meeting) {
            currentMeetingId = data.meeting.id;
            currentMeetingInfo = data.meeting;
            updateInfoTooltip(data.meeting);
          }
        } else if (data.type === 'show-standalone') {
          widgetContainer.classList.remove('select-mode');
          currentMeetingId = null;
          currentMeetingInfo = null;
          updateInfoTooltip(null);
        } else if (data.type === 'recording-started') {
          isRecording = true;
          recordingStartTime = data.startTime || Date.now();
          // v1.2 fix: Set meeting ID from the event
          if (data.meetingId) {
            currentMeetingId = data.meetingId;
          }
          if (data.meetingInfo) {
            currentMeetingInfo = data.meetingInfo;
            currentMeetingId = data.meetingInfo.id || currentMeetingId;
            updateInfoTooltip(data.meetingInfo);
          }
          // v1.2 fix: Hide options mode when recording starts
          hideRecordingOptions();
          widgetContainer.classList.remove('select-mode');
          updateUI();
          if (timerInterval) clearInterval(timerInterval);
          timerInterval = setInterval(updateTimer, 1000);
        } else if (data.type === 'recording-stopped') {
          isRecording = false;
          recordingStartTime = null;
          if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
          }
          updateUI();
        } else if (data.type === 'sync-state') {
          isRecording = data.isRecording;
          if (isRecording && data.startTime) {
            recordingStartTime = data.startTime;
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
          }
          // v1.2 fix: Set meeting ID from sync state
          if (data.meetingId) {
            currentMeetingId = data.meetingId;
          }
          if (data.meetingInfo) {
            currentMeetingId = data.meetingInfo.id || currentMeetingId;
            currentMeetingInfo = data.meetingInfo;
            updateInfoTooltip(data.meetingInfo);
          }
          // v1.2 fix: Also use currentViewedMeeting for info if no recording meeting
          if (!currentMeetingInfo && data.currentViewedMeeting) {
            currentMeetingInfo = data.currentViewedMeeting;
            currentMeetingId = data.currentViewedMeeting.id || currentMeetingId;
            updateInfoTooltip(data.currentViewedMeeting);
          }
          widgetContainer.classList.remove('select-mode');
          hideRecordingOptions();
          updateUI();
        } else if (data.type === 'always-on-top-changed') {
          isAlwaysOnTop = data.enabled;
          updatePinButton();
        } else if (data.type === 'meeting-info-update') {
          // v1.2 fix: Update meeting info when it changes (from app navigation)
          if (data.meetingInfo) {
            currentMeetingInfo = data.meetingInfo;
            currentMeetingId = data.meetingInfo.id || currentMeetingId;
            updateInfoTooltip(data.meetingInfo);
          }
          // Also handle currentViewedMeeting
          if (data.currentViewedMeeting) {
            currentMeetingInfo = data.currentViewedMeeting;
            currentMeetingId = data.currentViewedMeeting.id || currentMeetingId;
            updateInfoTooltip(data.currentViewedMeeting);
          }
        }
      });

      // Request initial state sync
      window.widgetAPI.requestSync();
    </script>
  </body>
</html>
